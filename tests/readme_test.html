<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Test: fetchGitHubReadme</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white p-10">

    <h1 class="text-3xl font-bold mb-6">Unit Tests: fetchGitHubReadme</h1>

    <div id="test-results" class="space-y-4"></div>

    <!-- Mocks for DOM elements required by the function -->
    <div id="github-readme" class="hidden mt-10 p-4 border border-gray-700">
        <h2 class="text-xl mb-2">DOM Mock Area</h2>
        <div id="readme-body"></div>
    </div>

    <!-- Load the function to test -->
    <!-- Note: We assume main.js has the function. If it has other side effects on load, we might need to adjust. -->
    <script>
        // Mocking marked library
        const marked = {
            parse: (text) => `<p>Parsed: ${text}</p>`
        };
    </script>
    <script src="../assets/js/main.js"></script>

    <script>
        // Test Runner
        const resultsDiv = document.getElementById('test-results');

        function assert(condition, message) {
            const div = document.createElement('div');
            div.className = condition ? 'p-4 bg-green-900/50 border border-green-500 rounded' : 'p-4 bg-red-900/50 border border-red-500 rounded';
            div.innerHTML = `
                <strong class="${condition ? 'text-green-400' : 'text-red-400'}">${condition ? 'PASS' : 'FAIL'}</strong>: ${message}
            `;
            resultsDiv.appendChild(div);
            return condition;
        }

        async function runTests() {
            const originalFetch = window.fetch;
            const readmeBody = document.getElementById('readme-body');
            
            // Helper to reset DOM
            const resetDOM = () => {
                readmeBody.innerHTML = '';
                document.getElementById('github-readme').classList.add('hidden');
            };

            // Test 1: Successful Fetch (Main Branch)
            try {
                resetDOM();
                window.fetch = async (url) => {
                    if (url.includes('main/README.md')) {
                        return {
                            ok: true,
                            status: 200,
                            text: async () => "# Hello World"
                        };
                    }
                    return { ok: false, status: 404 };
                };

                await fetchGitHubReadme();
                assert(readmeBody.innerHTML.includes('Parsed: # Hello World'), "Test 1: Should render content from main branch");
            } catch (e) {
                assert(false, `Test 1 Exception: ${e.message}`);
            }

            // Test 2: Fallback to Master Branch
            try {
                resetDOM();
                window.fetch = async (url) => {
                    if (url.includes('main/README.md')) {
                        return { ok: false, status: 404 };
                    }
                    if (url.includes('master/README.md')) {
                        return {
                            ok: true,
                            status: 200,
                            text: async () => "# Master Content"
                        };
                    }
                    return { ok: false, status: 404 };
                };

                await fetchGitHubReadme();
                // Wait a bit for the recursion
                await new Promise(r => setTimeout(r, 100));
                assert(readmeBody.innerHTML.includes('Parsed: # Master Content'), "Test 2: Should fallback to master branch on 404");
            } catch (e) {
                assert(false, `Test 2 Exception: ${e.message}`);
            }

            // Test 3: Both Branches 404 (Failure UI)
            try {
                resetDOM();
                window.fetch = async () => ({ ok: false, status: 404 });

                await fetchGitHubReadme();
                // Wait for retries (mocked or reduced for test?) 
                // The function has retries and timeouts. We need to mock setTimeout to speed this up or wait.
                // For this simple test, we might just check if it eventually fails or mock the recursion logic.
                // Actually, the current implementation calls itself recursively with setTimeout.
                // We will skip deep retry testing here to avoid long waits, or we can mock setTimeout.
                
                // Let's just test the UI update on failure if we force max retries
                await fetchGitHubReadme(2, 'master'); // Simulate last retry attempt
                
                assert(readmeBody.innerHTML.includes('Gagal memuat update terbaru'), "Test 3: Should show error UI after max retries");
            } catch (e) {
                assert(false, `Test 3 Exception: ${e.message}`);
            }

            // Restore
            window.fetch = originalFetch;
        }

        // Run tests after a short delay to ensure main.js is loaded
        setTimeout(runTests, 500);
    </script>
</body>
</html>
